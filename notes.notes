  __library >> SELECT *,  FROM (SELECT users.*, users_books.*
.............. FROM users
.............. INNER JOIN users_books
.............. ON users.id = users_books.user_id) u;


-------------- DO LATER --------------
### More query ideas.

We would like to leave you with some query ideas that you can try out on the library database that we have walked through in this book. In many cases, you may need to insert more data into your tables before you can create these queries.

    Select books that have never been checked out
    Select user that has the most books checked out
    Select users that are most active
    Select users with the most books
    Select users with the most reviews
    Select queries with =, vs in, vs Not IN, vs Like
    SQL queries with wild card search and limit

### M-to-M exercise 5 further exploration: lag



Docs video:
  - description of syntax box:
    - anything inside square brackets "[ ]" ---> optional
      - everything else is required
    - "{ }" ---> choose one
        ex: "{ UNION | INTERSECT | EXCEPT }"
    - <bold/italic terms>: more info about term is somewhere in page later


PSQL review video:
  - <modifiers column>: meta-data about the column that DB uses when you're inserting values or modifying already existing values
  - <indexes and constraints>: things that DB uses to enforce rules about what data can be stored in the table, as well as the relationships b/w values in diff. places and diff. tables


# remember!
[sql]
      SELECT year / 10 * 10 AS decade, genre, string_agg(title, ', ') AS films
        FROM films GROUP BY decade, genre ORDER BY decade, genre;
[/sql]



------------------------------------------------------------------------
    ### LESSON 2 ASSIGNMENT 10 NOTES ###
      - "https://launchschool.com/lessons/d8c90dd4/assignments/7761a32a"
      - how SELECT works underneath
------------------------------------------------------------------------



--------- Lessos 2 Assignment 11 VIDEO - Table and COlumn Aliases-------------

- alias: using the AS keyword in SQL to rename s/t that exists in database or schema
  - when you alias a table, that becomes the name you # have to use # for the rest of the query (# you can't use original name!)
  - we can replace original name w/ alias to make query shorter and easier to understand
  - usually alias using the first letter of the table

  - generally it's good not to alias table names unless you absolutely have to

  - always good to alias functions like count, so that column name makes more sense

- no need to specify table when SELECTing a column and JOINing 2 tables if column name is unique to both tables




--------- Lesson 3 Database Diagrams: Levels of Schema VIDEO -------------
####################### WATCH AGAIN AND TAKE MORE NOTES! ######################

- *conceptual schema* => high-level design focused on identifying entities and their relationships
  - *entity relationship model* (*ERD*) (*entity relationship diagram*) => a conceptual schema  !!! FLASH CARD...? !!!
    - deals w/ <entities>

- *physical schema* => low-level DB-specific design focused on implementation





--------- Lesson 3 Database Diagrams: Cardinality and Modality VIDEO ---------
####################### WATCH AGAIN AND TAKE MORE NOTES! ######################

- *cardinality* => the number of objects on each side of the relationship (1:1, 1:M, M:M)

- *modality* => if the relationship is required (1) or optional (0)
  - required (1) => has to be at least one instance of that entity
  - not requried (optional) (0) => don't need to be any instances at all
  - the lower bound on how many instances there can be in a relationship

- <one-to-one relationships> are rare in databases
  - two entitities w/ a one-to-one relationship can often be combined into 1 entity and/or stored in the same table
  - the physical schema you create for a one-to-one rel is the same as a one-to-many rel
  - which primary key should be used as the foreign key is ambiguous

- *crows foot notation* => a database diagram notation that literally represents rels

- important things to consider when looking at diagrams
  - what level of schema is it representing?
  - how are the different kinds of rels represented?
  - are the attributes and entities shown, and if so how?




--------- Lesson 3 JOINs VIDEO ---------
!!!!!!!! FLASH CARDS!!!!!!!
- INNER JOIN tells DB that it needs to find a matching row in both tables in order to return a row for either one
  - so INNER JOIN is good when you know there will always be a mtaching value in both tables

- LEFT OUTER JOIN => always get all rows from left table, but only matching rows from right table

- LEFT OUTER JOIN is more commonly used

- usually JOIN is equivalent to INNER JOIN
- usually LEFT JOIN is equivalent to LEFT OUTER JOIN
  - but it's best to use most explicit name for understandiblity

- CROSS JOIN => not common; generates every combo of 2 tables

- alternative ways to write JOINS:
  - CROSS JOIN
      ex: SELECT * FROM users, comments;
  - INNER JOIN
      ex: SELECT * FROM users, comments WHERE comments.user_id = users.id
  - # best to use explict JOIN format!


[sql]
  SELECT customers.id, customers.email, COUNT(DISTINCT tickets.event_id)
    FROM customers INNER JOIN tickets ON tickets.customer_id = customers.id
    GROUP BY customers.id
    HAVING COUNT(DISTINCT tickets.event_id) = 3;
[/sql]




----------------------- DDL EXERCISES ----------------------------------------
#################### possible notes/flashcards.... ###########################
    - data types (numeric, real, etc)
    - IN operator
    - how altering table's schema affects data in rows (type, constraints, etc)





--------------------- LESSON 4 - Interacting w/ a DB in code  -----------------

A-3 VIDEO - Excuting SQL statements from Ruby:

- pg gem: default Postgres adapter gem for Ruby

- tuple => a Ruby hash (in pg gem) (different meaning in DB terminology)
- semicolons are optional when using pg gem (it adds it for you automatically)
- always have a separate exec call for every statment

#### flashcards/notes -----> pg methods



A-4 Video - Demo:
  # .... #

A-10... Notes:
  # take notes! #

A-11: Video - Code Structure (diagram):
  # take notes! #

A-12 Notes:
  - ILIKE => case insenstivie version of LIKE operator

A-13.... etc:
  # review? #




--------------------- LESSON 5 - Database-backed Web Apps  -----------------

What schema does an application require?:
  - # Being able to map the data used by a project to a database schema is an important skill.

A-3 Project Overview Video:
  # watch again and take notes! #

A-4... etc...:
  # take notes... #

Load_todos video:
  - by default, everything we send to or get back from PG gem that gets turned into a query or gets sent back as result is a <string>

- sinatra reloader can load more files:
  - "http://www.sinatrarb.com/contrib/reloader"

SELECT lists.id, lists.name, sub.incomplete, count(todos.list_id) AS total
FROM lists LEFT OUTER JOIN todos ON todos.list_id = lists.id
LEFT OUTER JOIN
  (SELECT list_id, count(*) AS incomplete FROM todos
   WHERE completed = false
   GROUP BY list_id)
 AS sub ON sub.list_id = lists.id
GROUP BY lists.id, sub.incomplete;



--------------------- LESSON 6 - Optimizing SQL Queries  -----------------
KEY POINTS:
  - #  what are N + 1 queries
    - #  how can they be addressed?
  - #  what is a subquery?
    - #  how to use it?

A-1 video:
  - < N + 1 query > => #  total num of queries == num of elems on screen + 1 for original query
    - ex: loading todo lists on "/lists"

  -basic web dev pattern:
    - get things to work using basic methods
    - after, go and optimize things to improve performance

  - minimzing amount of SQL queries needed to display a page is an important way to optimize
    - allows us to sustain a larger num of users, and also make better use of resources on host



- many queries can be accomplished by using either JOINs or subqueries


A-3 video - optimizing n+1 queries:
  # TAKE NOTES FROM VIDEO AT 18:20-end!!!

  - only optimize like this when really necessary
    - like after you notice performance issues
      - then you can create special case queries liek this
  - more generalized queries makes developing app much simpler and convenient



A-3 video - pushing down operations to the DB:
  # maybe take more notes...?

  - it's more efficent to get DB to count things than Ruby
    - especially w/ large amounts of data!

# what we did in video:
  1. we moved some business logic from the app into the DB (ie, count)
    - allows us to perform same functionality in more efficient way

  2. we standardized how hashes are used in the app, and made sure that they always have the same keys in them
    - makes app simpler
    - lets us rely on fact that certain keys will always be there

  3. we changed way we load data for a list page
    - load list hash into ivar
    - load todos into separate ivar




----------------- TO STUDY -------------------
  - #  review all 'what to focus on' and 'summaries'






---------- questions ------------

- difference b/w entity and entity instance?
- "Relational databases are called relational because they persist data in a set of relations"
  - # lookup # ---> "persist data in a set of relations"...

- # heroku todos internal server error??







---------------------------------------------------
[sql]



INSERT INTO lists (name) VALUES
  ('Groceries'),
  ('Homework'),
  ('Chores'),
  ('Work'),
  ('Trips'),
  ('Calls'),
  ('Errands');

INSERT INTO todos (name, completed, list_id) VALUES
  ('Science', false, 1),
  ('Math', false, 1),
  ('Lettuce', false, 2),
  ('Cheese', false, 2),
  ('Onion', true, 2),
  ('Dust bookshelves', false, 4),
  ('Grocery store', false, 8),
  ('Cleaners', false, 8),
  ('Bank', true, 8),
  ('Library', false, 8);


SELECT lists.id, lists.name, sub.incomplete, count(todos.list_id) AS total
FROM lists LEFT OUTER JOIN todos ON todos.list_id = lists.id
LEFT OUTER JOIN
  (SELECT list_id, count(*) AS incomplete FROM todos
   WHERE completed = false
   GROUP BY list_id)
 AS sub ON sub.list_id = lists.id
GROUP BY lists.id, sub.incomplete;



SELECT lists.*,
       count(todos.id) AS todos_count,
       count(nullif(todos.completed, true)) AS todos_remaining
  FROM lists
    LEFT JOIN todos ON todos.list_id = lists.id
  GROUP BY lists.id;


[end]





----------- backup from DB_persistence.rb -------------------------
[ruby]

def all_lists
  sql = <<~SQL
    SELECT lists.id, lists.name, sub.incomplete, count(todos.list_id) AS total
    FROM lists LEFT OUTER JOIN todos ON todos.list_id = lists.id
    LEFT OUTER JOIN
      (SELECT list_id, count(*) AS incomplete FROM todos
       WHERE completed = false
       GROUP BY list_id)
     AS sub ON sub.list_id = lists.id
    GROUP BY lists.id, sub.incomplete;
  SQL
  result = query(sql)

  result.map do |tuple|
    list_id = tuple['id'].to_i

    { id:    list_id,
      name:  tuple['name'],
      todos: create_empty_todos(tuple['incomplete'], tuple['total']) }
  end
end

def create_empty_todos(incomplete, total)
  num_complete = total.to_i - incomplete.to_i
  num_incomplete = incomplete.to_i

  [ *(1..num_complete).map { |n| { id: 0, name: '', completed: true } },
    *(1..num_incomplete).map { |n| { id: 0, name: '', completed: false } } ]
end


### IMPLEMENT...?
  # def error=(msg)
  #   session[:error] = msg
  # end

  # def success=(msg)
  #   session[:success] = msg
  # end

[end]
