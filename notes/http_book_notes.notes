
---------- HTTP Background ----------

- *web browser* => interface or window thru which you interact w/ WWW
  - most common type of *client*
  - sends files to/from *server* thru HTTP
  - <debugging tools (dev tools)> => use to inspect HTTP activity of a page
- *HTTP* (*Hypertext Transfer Protocol*) => # an agreement in the form of formatted text that dictates how a client and server communicate
  - *protocol* => a system (set) of rules
  - HTTP is a <text-based> *request response protocol* => a <client> makes a *request* to a <server>, and waits for a *response*

How the Internet Works:
  - *IP Address* => unique labels assigned by an ISP to every device on Internet
    - *port numbers* => add more detail about how to communicate
  - *DNS* (*Domain Naming System*) => a <distributed database> that translates URLs to IP addresses, and maps the request to a remote server
    - *DNS servers* => computers that store <DNS databases>
      - # there is a world-wide network of hierarchically organized DNS servers
        - # no single server contains the complete database
          - DNS server routes unknown <domain names> to another server up the hierarchy
  - <Typical interaction w/ the Internet>:
    1. enter "google.com" (<host>) into browser
    2. your <request> is sent to your device's network interface
    3. request goes over Internet --> search for "google.com" begins
    4. remote server accepts and processes request --> sends <response> over Internet to your network interface --> then response handed to browser
    5. browser processes and displays response in form of a web page
    - # when your browser issues a request, it's just sending some text to an IP address

Resources:
  - *resources* => things you interact w/ on the Internet via a URL
    ex: images, videos, web pages, other files, software, etc...

Statelessness:
  - *state* => data that persists over time
  - *stateless protocol* => each <request/response> pair is independent of previous one
    - # server does not need to hang on to info (state) b/w requests
      - (if request breaks en route to server, no part of the system has to do any cleanup)
  - makes the web both:
    - # resilient, distributed, and hard to control
    - # difficult to secure and build on top of


---------- URL ----------

- *URI* => Uniform Resource Identifier
  - specifies how resources are located
  - *URL* => Uniform Resource Locator
    - most commonly used part of a URI
    - like an address / phone number

URL Components:
  ex: "http://www.example.com:88/home?item=book"
    1. "http" => *scheme* / <protocol>
      - tells the web client how to access the resource
    2. "www.example.com" => *host*
      - tells the client where the resource is hosted or located
    3. ":88" => *port* or port number
      - only required when using a non-default port (80)
    4. "/home/" => *path*
      - shows what local resource is being requested
    5. "?item=book" => *query string*
      - made up of *query parameters*
      - used for sending data to the server (optional)

Query Strings/Parameters:
  ex: "http://www.example.com?search=ruby&results=10"
    - "?" => delimits <path> and <start of query string> (reserved char)
    - "search=ruby" => <parameter name/value pair>
    - "&" => query string <separator/delimiter> (reserved char)
      - used to combine multiple parameters
  - # query strings are only used in HTTP GET requests
    - b/c they're passed in thru the URL
  - use %20 or "+" to encode a space " " in a query param
  - <query string limitations>:
    - max length --> so not good for passing large amounts of data
    - name/value pairs are visible in URL --> so not good for sensitive info
    - spaces and special chars must be URL encoded

URL Encoding:
  - replace special chars w/ % symbol followed by 2 hex digits (ASCII code)
      ex: " " --> %20, "!" --> %21, "+" --> %2B, "#" --> %23
  - characters must be encoded if:
    1. they have <no corresponding ASCII char>
    2. use of char is <unsafe>
      ex: "%" => used for encoding other chars
    3. char is <reserved for special use> w/i the URL scheme
      - # reserved char must be encoded if used for non-reserved purpose
      ex: "/ ? : @ &"
        ex: ":" => used to delimit host/port components and user/password


------------ Making Requests ---------------

Request Methods:
  - *HTTP Request Method* => tells server what action to perform on a resource
    - sent to a *host*
    - *GET*  => # retrieves resources
    - *POST* => # initiates action on or sends data to a server
  - every <request> gets a *response* (incl. errors) (except if it times out)
  - <components of http request>:
    - # required #: *method*, *path*
      - "/" => <root path>
    - optional: parameters, headers, body

GET Requests:
  ex: - entering address into address bar
      - clicking on a link (usually)
  - response can be anything
    - if it's HTML that references other resources:
      --> browser will automatically request those resources
      --> pure HTTP tool will not

POST Requests:
  ex: submitting a form
  - # allows us to send larger or sensitive data to server
    ex: images, videos, username/password
  - *HTTP body* => contains the data transmitted in an HTTP msg (optional)
    ex: use to send a POST request w/ text, images, HTML, etc

HTTP Headers:
  - *HTTP Headers* => allow client and server to send extra info (<meta-data>) during request/response HTTP cycle (optional)
    - colon separated name-value pairs sent in plain text
    - *Request Headers* => give more info about the client and resource to be fetched
      ex: Host, Accept-Language, User-Agent, Connection


------------ Processing Responses --------------

- *response* => raw HTTP data sent back by server

Status Code:
  - *HTTP Status Code* => 3 digit num that server sends back after receiving a request to signify status of request (# required #)
    - *status text* => description of code
    - < 200: OK >: the request was handled # successfully
    - < 302: Found >: the requested resource has changed temporarily (moved)
      - usually results in a *redirect* (re-route) to another URL
    - < 404: Not Found >: the requested resource cannot be found
    - < 500: Internal Server Error >: the server has encountered a generic error

! 302-500 TAKE NOTES!!!

Response Headers:
  - *Response headers* => meta-data about resource being sent back (optional)
    - have subtle effects on the data being returned
    - can also have subtle workflow consequences
      ex: browser automatically following a Location response header
    ex: Content-Encoding, Server, Location, Content-Type

- *body* => contains the raw response data (optional) (ex: HTML)


------------ Stateful Web Applications ----------------

Sessions:
  - *session identifier* => unique token that gets passed back and forth b/w server and client to <id> a client to mimic statefulness
  - <consequences of faux statefulness>:
    1. every request must be inspected to see if it contains a <session id>
    2. if so, id must be checked for validity
      - (server needs rules for how to handle session expiration and how to store its session data)
    3. server must retrieve <session data> based on session id
    4. server must recreate <application state> (ex: HTML) from session data and send it back to client as response
    - # server has to work very hard to simulate a stateful experience
    - # every request still gets its own response, even if most of that response is identical to the previous response

Cookies:
  - *HTTP cookies* => small files sent from server and stored in client containing session info
  - # the session id (cookie) is stored client-side, and used as a 'key' to the session data stored server-side

AJAX:
  - *AJAX* (*Asynchronous JavaScript and XML*) => allows browsers to issue requests and process responses # without a full page refresh
  ex: Google search -- an AJAX request is triggered w/ every key-press
    - the responses from these requests are processed by some callback
      - *callback* => a piece of logic you pass on to some function to be executed after a certain event has happened
        - usually some client-side JS code
        ex: update the HTML w/ new search results
  - AJAX requests are just like normal requests, except the response is processed by a <callback function> instead of the browser refreshing


--------------- Security ----------------

Secure HTTP (HTTPS):
  - all info in request/response are sent as strings in regular HTTP
    - so a hacker on the same network could use <packet sniffing> to read them
      - they could copy your session id to login to your account
  - *HTTPS* => every request/response is <encrypted> before being transported
    - sends messages thru a cryptographic protocol called *TLS* (Transport Layer Security) or *SSL* (Secure Sockets Layer) (deprecated)
      - uses <certificates> to communicate w/ remote servers and exchange security keys before data encryption happens
  - port 443 (default)

Same-origin policy:
  - *same origin policy* => prevents scripts from one site from manipulating documents from another site
    - documents in the same *origin* must have same protocol, hostname, and port number
      ex: "http://www.test.com/index.html" can embed JS file at "http//www.test.com/fancy.js" but not any JS files at "http://www.example.com"
    - guards against <session hijacking> attacks
  - *CORS* => *Cross Origin Resource Sharing* => bypasses same-origin policy
    - works by adding new HTTP headers

Session Hijacking:
  - *session hijacking* => attacker uses <session id> to access a user's session
  - <countermeasures>:
    - <resetting sessions>: w/ authentication systems, a successful login must render an old session id invalid and create a new one
    - setting an <expiration time> on sessions: less time for hacker to access
    - <HTTPS>: lowers chances of attacker being able to get session id

Cross-Site Scripting (XSS):
  - *XSS* (*Cross Site Scripting*) => attack that happens when users are allowed to directly input HTML or JS that gets displayed by the site directly
    ex: comments page can have comments w/ HTML/JS that browser will execute
      - bypasses same-origin policy
      ex: can be used to grab session ids, etc
  - <countermeasures>:
    - always <sanitize user input>
    - escape all user input data when displaying it, so browser won't interpret it as code


--------------- Server-side Development ----------------

- 3 main parts of <server-side infrastructure (a 'server')>:
  1. *web server* => a simple server that responds to static assets (ex: files, images, css, JS, etc) that don't require any data processing
  2. *application server* => where application or business logic (<server-side code>) resides
    - where more complicated requests are handled
  3. persistent *data store* => often consulted by application server to retrieve, process or create data
    ex: relational database, file, key/value store, etc.
- there are many <layers> at work for client to send request to server
  - to send a request from computer to one of Google's servers, it takes coordination b/w many (100+) software applications and machines
  - 7 types of layers in OSI:
    ex: (application, presentation, session, transport, network, data link, physical)
  - HTTP is an <application layer protocol> => a convention or agreement (on # how to format a string request #) b/w 2 parties
    ex: <application protocol>: sending a date/location request in specific format "MM/DD/YYYY; ZIPCODE" instead of writing out full date in words
  - <TCP/IP (Transmssion Control Protocol)> => large set of protocols that govern how systems should communicate w/ each other over the internet
    - collectively known as the <OSI (Open Systems Interconnection) model>
    - represents the lower layers in the communication stack
    - HTTP uses <TCP/IP> under the hood as the <transport/network layers>
      - TCP/IP is responsible for ensuring request/response cycle gets completed

!!! LESSON 3 VIDEO NOTES.....
!!! RACK BLOG, ETC....

- *Rack* => a web server interface
- "https://launchschool.com/posts/af8dd016"
  - *web application server* => the software program that's running your <server-side> code
    ex: Webrick
  - *web application* => the 'infrastructure that's running the server-side code'
    - # very vague and generic term!
  - *web framework* => collectio nof libraries/code that work together for a specific purporse (ex: building webb apps, writing tests, etc)


------------------ Sinatra ------------------

- Sinatra is a <small web framework> (<DSL> for defining <routes>)
  - HTTP <requests> handled by # creating routes for a path or set of paths
    - *routes* => how a developer maps a URL pattern to some Ruby code
      - create by using methods w/ same name as HTTP method to be handled
- *template* (*view template*) => files that contain text that is converted into HTML before being sent to a user's browser in a response
  - provide a place to # define the HTML display of a response # outside of the route handling it
  - *templating language* => provides a way to define what HTML to generate and how to embed dynamic values
  - *layouts* => view templates that wrap around other view templates
    - # provide shared HTML that is used by all views
    - often include links to stylesheets or JS files
- *ERB* (*embedded Ruby*) => templating language that embeds Ruby into another file
  - expressions in "<%= %>" tags will be replaced when template is <rendered>
    ex: <printing a dynamic value> => "<h1><%= @title %></h1>"
- *helper* / *view helper* => Ruby methods used to minimize amount of Ruby code in a view template
  - defined w/i a *helpers* block
  - filter/process data that is being rendered into the page
- *redirect* method => sends user to new location in response to a request w/ *redirection*
  - accomplished by setting the <Location header> in the response
  - client sees URL in Location header and sends out a new GET request for the associated resource ---> navigates client to that new location
  ex: often used after user creates/updates data, like after submitting a form
- code placed in a *before* block is executed before the matching route for every request

Parameters:
- routes can specify *parameters* by: "/route_name/:param_name"
  - access w/i route using: "params[:param_name]"
- # 3 ways to get data into params hash:
  1. extract from URL (ex: "chapters/1")
  2. use <query params> in URL (ex: "/?sort=desc")
  3. submitting a form using a <POST> request

How HTML Forms Work:
  - when a *form* is submitted, browser makes <HTTP request>
  - request is made to path or URL specified in the <action attribute> of the <form element>
  - <method attribute> of the form determines if request made will use <GET or POST>
  - the <value> of any <input elements> in the form will be sent as <params>
    - the <keys> of these params are determined by the <name attribute> of the corresponding <input element>

- use <GET> when form submission # doesn't modify any data # (ex: <search>)
  - use <POST> when # form submission modifies data

Server-side code vs. Client-side code:
- based on # where the code will be evaluated
  - *Server side*:
    - *Gemfile* => executed by Bundler gem to install libraries needed to run program
      - <Bundler> => Ruby dependency management system
    - *ruby files* (".rb") => core of sinatra app
      - code runs on server while handling incoming requests
    - *view templates* (".erb") => Ruby code inside is evaluated on server to generate response to send to client
      - # b/c they must be processed by a program on server before being sent to client
      aka: <server-side templates> (vs. client-side templates (JS))
  *Client side*:
    - *stylesheets* (".css") => code is interpreted by web browser (client) as instructions for how to display web page
    - *JavaScript* (".js") => code is evaluated by JS interpreter w/i browser to <add behavior> to web page



###Critique someone else's code, then compare your thoughts to the TA's

# To get this to work in development you have to add this line set :show_exceptions, :after_handler. I put that line just below my require 'pry'

# show_exceptions
   # Show a stack trace in the browser when an exception happens. Enabled by default when environment is set to "development", disabled otherwise.
  #  Can also be set to :after_handler to trigger app-specified error handling before showing a stack trace in the browser.


-------------- Heroku ---------------

- <Procfile> => defines what type of processes are provided by the app and how to start them
- <config.ru> => tells web server how to start the app
- <Puma> => a production-ready web server for deploying projects
  - <threaded> web server ---> so it can handle more than 1 request at a time using a single process (faster performance)
- <Webrick> => web server for development


------------ Todos ---------------

Session: see videos!
- don't put methods not used in view templates in <helpers> block

# SINATRA STORES METHODS THAT GET DELETED!!! (EX: total_todos(list))
  # RESTART SERVER TO FIX!!

- *state* => data that persists over time
- *session* => provides a way to store data that will persist b/w HTTP reqeusts
  - associated w/ a specific user by storing a cookie in their browser
  - in Sinatra, the session data itself is also stored in this cookie
    - this is configureable and not always the case /w other web freameworks
- data that is submittied to server often needs to be <validated> to ensure it meets requirements of app
  - in Todos, we built <server-side> validation ---> we perofrmed the validation logic on the server
- *flash message* => messages that need to be displayed to user on their next request and then deleted can be stored in the session
- content from w/i a view template can be stored under a name and retrieved later using "#content_for" and "#yield_content"
- GET request should only request data
  - use POST or another non-GET method for any request that modifies data
- web browsers only support GET and POST in HTML <forms>, so sometimes need to use POST instead of a more appropriate method
- *view helpers* => provide a way to extract code that determines what HTML markup is generated for a view



------------------ Securing Applications -------------------

- # escape HTML!

- Neither POST nor GET is a secure HTTP method
  - # Any request sent as plain text, regardless of the HTTP method used, is equally vulnerable to being seen while in transit on the network
  - (you can still see the parameters very easily in headers)
- # Serving the app over HTTPS is the only way to protect a user's data
  -


----------------- CMS Project -------------------

Approach:
  1. *requirements*
    - <what> does the app need to do to satisfy requirements?
    - <how> will the app accomplish these things?
      - <what> changes need to be made?
  2. *implementation* ---> create your own plan from requirements
  3. *solution*
    - <how> is yours different?
      - will there be any noticeable difference to a user?
    - *tests*
      - think about what the tests should be doing and write your own
      - then compare your tests to example tests
      - then write and verify the rest of the solution

RACK INFO: http://blog.gauravchande.com/what-is-rack-in-ruby-rails
- pretty print a "last_response" obj => " puts last_response.to_yaml "
- # get last_response["Location"]    ===    follow_redirect!    ???