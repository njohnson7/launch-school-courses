---------- HTTP Background ----------

- *web browser* => interface or window thru which you interact w/ WWW
  - most common type of *client*
  - sends files to/from *server* thru HTTP
- *HTTP* => *Hypertext Transfer Protocol*
  - a system of rules (a <protocol>) that serve as a link b/w applications and the transfer of hypertext documents
  - # an agreement in the form of formatted text that dictates how a client and server communicate
  - HTTP is a *request response protocol* => a <client> makes a *request* to a <server>, and waits for a *response*

How the Internet Works:
- *IP Address* => unique labels assigned by an ISP to every device on Internet
  - *port numbers* => add more detail about how to communicate
- *DNS* (*Domain Naming System*) => a <distributed database> that translates URLs to IP addresses, and maps the request to a remote server
  - *DNS servers* => computers that store <DNS databases>
    - # there is a world-wide network of hierarchically organized DNS servers
      - # no single server contains the complete database
        - DNS server routes unknown <domain names> to another server up the hierarchy
- <Typical interaction w/ the Internet>:
  1. enter "google.com" into browser
  2. your <request> is sent to your device's network interface
  3. request goes over Internet --> search for "google.com" begins
  4. remote server accepts and processes request --> sends <response> over Internet to your network interface --> then response handed to browser
  5. browser processes and displays response in form of a web page
  - # when your browser issues a request, it's just sending some text to an IP address

Resources:
- *resources* => things you interact w/ on the Internet via a URL
  ex: images, videos, web pages, other files, software, etc...

Statelessness:
  - *stateless protocol* => each <request/response> pair is independent of previous one
    - # server does not need to hang on to info (state) b/w requests
      - (if request breaks en route to server, no part of the system has to do any cleanup)
  - makes the web both:
    - # resilient, distributed, and hard to control
    - # difficult to secure and build on top of



---------- URL ----------

- *URI* => Uniform Resource Identifier
  - specifies how resources are located
  - *URL* => Uniform Resource Locator
    - most commonly used part of a URI
    - like an address / phone number

URL Components:
  ex: "http://www.example.com:88/home?item=book"
    1. "http" => *scheme*
      - tells the web client how to access the resource
    2. "www.example.com" => *host*
      - tells the client where the resource is hosted or located
    3. ":88" => *port* or port number
      - only required when using a non-default port (80)
    4. "/home/" => *path*
      - shows what local resource is being requested (optional)
    5. "?item=book" => *query string*
      - made up of *query parameters*
      - used for sending data to the server (optional)

Query Strings/Parameters:
  ex: "http://www.example.com?search=ruby&results=10"
    - "?" => marks <start of query string> (reserved char)
    - "search=ruby" => <parameter name/value pair>
    - "&" => query string <separator/delimiter> (reserved char)
      - used to combine multiple parameters
  - # query strings are only used in HTTP GET requests
    - b/c they're passed in thru the URL
  - <query string limitations>:
    - max length --> so not good for passing large amounts of data
    - name/value pairs are visible in URL --> so not good for sensitive info
    - spaces and special chars must be URL encoded

URL Encoding:
  - replace special chars w/ % symbol followed by 2 hex digits (ASCII code)
      ex: " " --> %20, "!" --> %21, "+" --> %2B, "#" --> %23
  - characters must be encoded if:
    1. they have <no corresponding ASCII char>
    2. use of char is <unsafe>
      ex: "%" => used for encoding other chars
    3. char is <reserved for special use> w/i the URL scheme
      - # reserved char must be encoded if used for non-reserved purpose
      ex: "/ ? : @ &"
        ex: ":" => used to delimit host/port components and user/password


------------ Making Requests ---------------

Request Methods:
  - *HTTP Request Method* => tells server what action to perform on a resource
    - *GET*  => retrieves resources
    - *POST* => initiates action on or sends data to a server
  - every <request> gets a *response* (incl. errors) (except if it times out)

GET Requests:
  ex: - entering address into address bar
      - clicking on a link (usually)
  - response can be anything
    - if it's HTML that references other resources:
      --> browser will automatically request those resources
      --> pure HTTP tool will not

POST Requests:
  ex: submitting a form
  - # allows us to send larger or sensitive data to server
    ex: images, videos, username/password
  - *HTTP body* => contains the data transmitted in an HTTP msg (optional)
    ex: use to send a POST request w/ text, images, HTMKL< etc

HTTP Headers:
  - *HTTP Headers* => allow client and server to send extra info during request/response HTTP cycle
    - colon separated name-value pairs sent in plain text
    - *Request Headers* => give more info about the client and resource to be fetched
      ex: Host, Accept-Language, User-Agent, Connection


------------ Processing Responses --------------

*response* => raw HTTP data sent back by server

Status Code:
  - *HTTP Status Code* => 3 digit num that server sends back after receiving a request to signify status of request
    - *status text* => description of code
    - < 200: OK >: the request was handled successfully
    - < 302: Found >: the requested resource has changed temporarily (moved)
      - usually results in a *redirect* (re-route) to another URL
    - < 404: Not Found >: the requested resource cannot be found
    - < 500: Internal Server Error >: the server has encountered a generic error

! 302-500 TAKE NOTES!!!

Response Headers:
  - *Response headers* => give additional meta-info about resource being sent back
    - have subtle effects on the data being returned
    - can also have subtle workflow consequences
      ex: browser automatically following a Location response header
    ex: Content-Encoding, Server, Location, Content-Type

- *message body* => contains the raw response data (ex: HTML)